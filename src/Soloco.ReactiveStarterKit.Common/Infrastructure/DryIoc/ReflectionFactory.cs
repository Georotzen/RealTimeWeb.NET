using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using System.Text;

namespace Soloco.ReactiveStarterKit.Common.Infrastructure.DryIoc
{
    /// <summary>Reflects on <see cref="ImplementationType"/> constructor parameters and members,
    /// creates expression for each reflected dependency, and composes result service expression.</summary>
    public sealed class ReflectionFactory : Factory
    {
        /// <summary>Non-abstract service implementation type. May be open generic.</summary>
        public override Type ImplementationType { get { return _implementationType; } }

        /// <summary>Provides closed-generic factory for registered open-generic variant.</summary>
        public override IConcreteFactoryGenerator FactoryGenerator { get { return _factoryGenerator; } }

        /// <summary>Indicates that factory is for closed-generic type and been generated by open-generic original factory.</summary>
        public override int GeneratorFactoryID { get { return _generatorFactoryID; } }

        /// <summary>Injection rules set for Constructor, Parameters, Properties and Fields.</summary>
        public readonly Made Made;

        /// <summary>Creates factory providing implementation type, optional reuse and setup.</summary>
        /// <param name="implementationType">(optional) Optional if Made.FactoryMethod is present Non-abstract close or open generic type.</param>
        /// <param name="reuse">(optional)</param> <param name="made">(optional)</param> <param name="setup">(optional)</param>
        /// <param name="generatorFactoryID">(optional) Specifies that factory is generated from open-generic original with specified ID.</param>
        public ReflectionFactory(Type implementationType = null, IReuse reuse = null, Made made = null, Setup setup = null, int generatorFactoryID = -1)
            : base(reuse, setup)
        {
            Made = made ?? Made.Default;
            _generatorFactoryID = generatorFactoryID;

            _implementationType = ValidateAndNormalizeImplementationType(implementationType);

            if (_implementationType != null && _implementationType.IsGenericDefinition())
                _factoryGenerator = new ClosedGenericFactoryGenerator(this);
        }

        /// <summary>Before registering factory checks that ImplementationType is assignable, Or
        /// in case of open generics, compatible with <paramref name="serviceType"/>. 
        /// Then checks that there is defined constructor selector for implementation type with multiple/no constructors.</summary>
        /// <param name="container">Container to register factory in.</param>
        /// <param name="serviceType">Service type to register factory with.</param>
        /// <param name="serviceKey">(ignored)</param>
        /// <param name="isStaticallyChecked">Skips service type check. Means that service and implementation are statically checked.</param>
        public override void ThrowIfInvalidRegistration(IContainer container, Type serviceType, object serviceKey, bool isStaticallyChecked)
        {
            base.ThrowIfInvalidRegistration(container, serviceType, serviceKey, isStaticallyChecked);

            var implType = _implementationType;
            if (implType == null)
                return;

            if (!isStaticallyChecked)
            {
                if (!implType.IsGenericDefinition())
                {
                    if (implType.IsOpenGeneric())
                        Throw.It(Error.RegisteringNotAGenericTypedefImplType,
                            implType, implType.GetGenericDefinitionOrNull());

                    if (implType != serviceType && serviceType != typeof(object) &&
                        Array.IndexOf(implType.GetImplementedTypes(), serviceType) == -1)
                        Throw.It(Error.RegisterImplementationNotAssignableToServiceType, implType, serviceType);
                }
                else if (implType != serviceType)
                {
                    if (serviceType.IsGenericDefinition())
                    {
                        var implTypeParams = implType.GetGenericParamsAndArgs();
                        var implementedTypes = implType.GetImplementedTypes();

                        var implementedTypeFound = false;
                        var containsAllTypeParams = false;
                        for (var i = 0; !containsAllTypeParams && i < implementedTypes.Length; ++i)
                        {
                            var implementedType = implementedTypes[i];
                            implementedTypeFound = implementedType.GetGenericDefinitionOrNull() == serviceType;
                            containsAllTypeParams = implementedTypeFound &&
                                                    implementedType.ContainsAllGenericTypeParameters(implTypeParams);
                        }

                        if (!implementedTypeFound)
                            Throw.It(Error.RegisterImplementationNotAssignableToServiceType, implType, serviceType);

                        if (!containsAllTypeParams)
                            Throw.It(Error.RegisteringOpenGenericServiceWithMissingTypeArgs,
                                implType, serviceType,
                                implementedTypes.Where(t => ReflectionTools.GetGenericDefinitionOrNull(t) == serviceType));
                    }
                    else if (implType.IsGeneric() && serviceType.IsOpenGeneric())
                        Throw.It(Error.RegisteringNotAGenericTypedefServiceType,
                            serviceType, serviceType.GetGenericDefinitionOrNull());
                    else
                        Throw.It(Error.RegisteringOpenGenericImplWithNonGenericService, implType, serviceType);
                }
            }

            if (Made.FactoryMethod == null && container.Rules.FactoryMethod == null)
            {
                var publicCounstructorCount = implType.GetAllConstructors().Count();
                if (publicCounstructorCount != 1)
                    Throw.It(Error.NoDefinedMethodToSelectFromMultipleConstructors, implType, publicCounstructorCount);
            }
        }

        /// <summary>Creates service expression, so for registered implementation type "Service", 
        /// you will get "new Service()". If there is <see cref="Reuse"/> specified, then expression will
        /// contain call to <see cref="Scope"/> returned by reuse.</summary>
        /// <param name="request">Request for service to resolve.</param> <returns>Created expression.</returns>
        public override Expression CreateExpressionOrDefault(Request request)
        {
            var factoryMethod = GetFactoryMethod(request);

            // If factory method is instance method, then resolve factory instance first.
            Expression factoryExpr = null;
            if (factoryMethod.FactoryServiceInfo != null)
            {
                var factoryRequest = request.Push(factoryMethod.FactoryServiceInfo);
                var factoryFactory = factoryRequest.Container.ResolveFactory(factoryRequest);
                factoryExpr = factoryFactory == null ? null : factoryFactory.GetExpressionOrDefault(factoryRequest);
                if (factoryExpr == null)
                    return null;
            }

            Expression[] paramExprs = null;
            var constructorOrMethod = factoryMethod.ConstructorOrMethodOrMember as MethodBase;
            if (constructorOrMethod != null)
            {
                var parameters = constructorOrMethod.GetParameters();
                if (parameters.Length != 0)
                {
                    paramExprs = new Expression[parameters.Length];

                    var parameterSelector = request.Container.Rules.Parameters.And(Made.Parameters)(request);

                    var funcArgs = request.FuncArgs;
                    var funcArgsUsedMask = 0;

                    for (var i = 0; i < parameters.Length; i++)
                    {
                        var param = parameters[i];
                        Expression paramExpr = null;

                        if (funcArgs != null)
                        {
                            for (var fa = 0; fa < funcArgs.Value.Length && paramExpr == null; ++fa)
                            {
                                var funcArg = funcArgs.Value[fa];
                                if ((funcArgsUsedMask & 1 << fa) == 0 &&                  // not yet used func argument
                                    funcArg.Type.IsAssignableTo(param.ParameterType)) // and it assignable to parameter
                                {
                                    paramExpr = funcArg;
                                    funcArgsUsedMask |= 1 << fa;  // mark that argument was used
                                    funcArgs.Key[fa] = true;      // mark that argument was used globally for Func<..> resolver.
                                }
                            }
                        }

                        // If parameter expression still null (no Func argument to substitute), try to resolve it
                        if (paramExpr == null)
                        {
                            var paramInfo = parameterSelector(param) ?? ParameterServiceInfo.Of(param);

                            paramExprs[i] = TryInjectResolver(paramInfo) ?? TryInjectResolutionScope(paramInfo, request);
                            if (paramExprs[i] != null)
                                continue;

                            var paramRequest = request.Push(paramInfo);

                            var customValue = paramInfo.Details.CustomValue;
                            if (customValue != null)
                            {
                                customValue.ThrowIfNotOf(paramRequest.ServiceType, Error.InjectedCustomValueIsOfDifferentType, paramRequest);
                                paramExpr = paramRequest.Container.GetOrAddStateItemExpression(customValue, throwIfStateRequired: true);
                            }
                            else
                            {
                                var paramFactory = paramRequest.Container.ResolveFactory(paramRequest);
                                paramExpr = paramFactory == null ? null : paramFactory.GetExpressionOrDefault(paramRequest);
                                // Meant that parent Or parameter itself allows default value, 
                                // otherwise we did not get null but exception
                                if (paramExpr == null)  
                                {
                                    // Check if parameter itself (without propagated parent details) 
                                    // does not allow default, then stop checking the rest of parameters.
                                    if (paramInfo.Details.IfUnresolved == IfUnresolved.Throw)
                                        return null;

                                    var defaultValue = paramInfo.Details.DefaultValue;
                                    paramExpr = defaultValue != null
                                        ? paramRequest.Container.GetOrAddStateItemExpression(defaultValue)
                                        : paramRequest.ServiceType.GetDefaultValueExpression();
                                }
                            }
                        }

                        paramExprs[i] = paramExpr;
                    }
                }
            }

            return CreateServiceExpression(factoryMethod.ConstructorOrMethodOrMember, factoryExpr, paramExprs, request);
        }

        #region Implementation

        private readonly Type _implementationType;
        private readonly ClosedGenericFactoryGenerator _factoryGenerator;
        private readonly int _generatorFactoryID;

        private sealed class ClosedGenericFactoryGenerator : IConcreteFactoryGenerator
        {
            public IEnumerable<KV<Type, object>> ServiceTypeAndKeyOfGeneratedFactories
            {
                get
                {
                    return _generatedFactories.Value.IsEmpty
                        ? Enumerable.Empty<KV<Type, object>>()
                        : _generatedFactories.Value.Enumerate().Select(f => f.Value);
                }
            }

            public ClosedGenericFactoryGenerator(ReflectionFactory openGenericFactory)
            {
                _openGenericFactory = openGenericFactory;
            }

            public Factory GenerateFactoryOrDefault(Request request)
            {
                request = request.WithResolvedFactory(_openGenericFactory);

                var serviceType = request.ServiceType;
                var implementationType = _openGenericFactory._implementationType;

                var closedTypeArgs = implementationType == serviceType.GetGenericDefinitionOrNull()
                    ? serviceType.GetGenericParamsAndArgs()
                    : GetClosedTypeArgsOrNullForOpenGenericType(implementationType, request.ServiceType, request);

                if (closedTypeArgs == null)
                    return null;

                var made = _openGenericFactory.Made;
                if (made.FactoryMethod != null)
                {
                    var factoryMethod = made.FactoryMethod(request)
                        .ThrowIfNull(Error.Of("Got null factory method when resolving {0}"), request);

                    var closedFactoryMethod = GetClosedFactoryMethodOrDefault(factoryMethod, closedTypeArgs, request);
                    if (closedFactoryMethod == null) // may be null only for IfUnresolved.ReturnDefault
                        return null;

                    made = Made.Of(_ => closedFactoryMethod, made.Parameters, made.PropertiesAndFields);
                }

                var closedImplementationType = Throw.IfThrows<ArgumentException, Type>(
                    () => implementationType.MakeGenericType(closedTypeArgs),
                    request.IfUnresolved == IfUnresolved.Throw, 
                    Error.NoMatchedGenericParamConstraints, implementationType, request);

                if (closedImplementationType == null)
                    return null;

                var closedGenericFactory = new ReflectionFactory(closedImplementationType,
                    _openGenericFactory.Reuse, made, _openGenericFactory.Setup,
                    _openGenericFactory.FactoryID);

                // Storing generated factory ID to service type/key mapping 
                // to find/remove generated factories when needed
                _generatedFactories.Swap(_ => _.AddOrUpdate(closedGenericFactory.FactoryID,
                    new KV<Type, object>(serviceType, request.ServiceKey)));

                return closedGenericFactory;
            }

            private static FactoryMethod GetClosedFactoryMethodOrDefault(
                FactoryMethod factoryMethod, Type[] serviceTypeArgs, Request request)
            {
                var factoryMember = factoryMethod.ConstructorOrMethodOrMember;
                var factoryInfo = factoryMethod.FactoryServiceInfo;

                var factoryResultType = factoryMember.GetReturnTypeOrDefault();
                var implTypeParams = factoryResultType.GetGenericParamsAndArgs();

                // Get method declaring type, and if its open-generic,
                // then close it first. It is required to get actual method.
                var factoryImplType = factoryMember.DeclaringType.ThrowIfNull();
                if (factoryImplType.IsOpenGeneric())
                {
                    var factoryImplTypeParams = factoryImplType.GetGenericParamsAndArgs();
                    var resultFactoryImplTypeArgs = new Type[factoryImplTypeParams.Length];

                    var isFactoryImplTypeClosed = MatchServiceWithImplementedTypeParams(
                        resultFactoryImplTypeArgs, factoryImplTypeParams,
                        implTypeParams, serviceTypeArgs);

                    if (!isFactoryImplTypeClosed)
                        return request.IfUnresolved == IfUnresolved.ReturnDefault ? null
                            : Throw.For<FactoryMethod>(Error.NoMatchedFactoryMethodDeclaringTypeWithServiceTypeArgs,
                                factoryImplType, new StringBuilder().Print(serviceTypeArgs, itemSeparator: ", "), request);

                    // For instance factory match its service type from the implementation factory type.
                    if (factoryInfo != null)
                    {
                        // Open-generic service type is always normalized as generic type definition
                        var factoryServiceType = factoryInfo.ServiceType;

                        // Look for service type equivalent within factory implementation type base classes and interfaces,
                        // because we need identical type arguments to match.
                        if (factoryServiceType != factoryImplType)
                            factoryServiceType = factoryImplType.GetImplementedTypes()
                                .First(t => t.IsGeneric() && t.GetGenericTypeDefinition() == factoryServiceType);

                        var factoryServiceTypeParams = factoryServiceType.GetGenericParamsAndArgs();
                        var resultFactoryServiceTypeArgs = new Type[factoryServiceTypeParams.Length];

                        var isFactoryServiceTypeClosed = MatchServiceWithImplementedTypeParams(
                            resultFactoryServiceTypeArgs, factoryServiceTypeParams,
                            factoryImplTypeParams, resultFactoryImplTypeArgs);

                        // Replace factory info with close factory service type
                        if (isFactoryServiceTypeClosed)
                        {
                            factoryServiceType = factoryServiceType.GetGenericTypeDefinition();
                            var closedFactoryServiceType = Throw.IfThrows<ArgumentException, Type>(
                                () => factoryServiceType.MakeGenericType(resultFactoryServiceTypeArgs),
                                request.IfUnresolved == IfUnresolved.Throw,
                                Error.NoMatchedGenericParamConstraints, factoryServiceType, request);
                            if (closedFactoryServiceType == null)
                                return null;

                            // Copy factory info woth closed factory type
                            factoryInfo = ServiceInfo.Of(closedFactoryServiceType)
                                .WithDetails(factoryInfo.Details, request);
                        }
                    }

                    // Close the factory type implementation 
                    // and get factory member to use from it.
                    var closedFactoryImplType = Throw.IfThrows<ArgumentException, Type>(
                        () => factoryImplType.MakeGenericType(resultFactoryImplTypeArgs),
                        request.IfUnresolved == IfUnresolved.Throw,
                        Error.NoMatchedGenericParamConstraints, factoryImplType, request);
                    if (closedFactoryImplType == null)
                        return null;

                    // Find corresponding mamber again, now from closed type
                    var factoryMethodBase = factoryMember as MethodBase;
                    if (factoryMethodBase != null)
                    {
                        var factoryMethodParameters = factoryMethodBase.GetParameters();
                        var targetMethods = closedFactoryImplType.GetDeclaredAndBase(t => t.DeclaredMethods)
                            .Where(m => m.Name == factoryMember.Name && m.GetParameters().Length == factoryMethodParameters.Length)
                            .ToArray();

                        if (targetMethods.Length == 1)
                            factoryMember = targetMethods[0];
                        else // Fallback to  MethodHandle only if methods have similar signatures
                        {
                            var methodHandleProperty = typeof(MethodBase).GetPropertyOrNull("MethodHandle")
                                .ThrowIfNull(Error.OpenGenericFactoryMethodDeclaringTypeIsNotSupportedOnThisPlatform,
                                    factoryImplType, closedFactoryImplType, factoryMethodBase.Name);
                            factoryMember = MethodBase.GetMethodFromHandle(
                                (RuntimeMethodHandle)methodHandleProperty.GetValue(factoryMethodBase, ArrayTools.Empty<object>()),
                                closedFactoryImplType.TypeHandle);
                        }
                    }
                    else if (factoryMember is FieldInfo)
                    {
                        factoryMember = closedFactoryImplType.GetDeclaredAndBase(t => t.DeclaredFields)
                            .Single(f => f.Name == factoryMember.Name);
                    }
                    else if (factoryMember is PropertyInfo)
                    {
                        factoryMember = closedFactoryImplType.GetDeclaredAndBase(t => t.DeclaredProperties)
                            .Single(f => f.Name == factoryMember.Name);
                    }
                }

                // If factory method is actual method and still open-generic after closing its decalring type, 
                // then match remaining method type parameters and make closed method
                var openFactoryMethod = factoryMember as MethodInfo;
                if (openFactoryMethod != null && openFactoryMethod.ContainsGenericParameters)
                {
                    var methodTypeParams = openFactoryMethod.GetGenericArguments();
                    var resultMethodTypeArgs = new Type[methodTypeParams.Length];

                    var isMethodClosed = MatchServiceWithImplementedTypeParams(
                        resultMethodTypeArgs, methodTypeParams, implTypeParams, serviceTypeArgs);

                    if (!isMethodClosed)
                        return request.IfUnresolved == IfUnresolved.ReturnDefault ? null
                            : Throw.For<FactoryMethod>(Error.NoMatchedFactoryMethodWithServiceTypeArgs,
                                openFactoryMethod, new StringBuilder().Print(serviceTypeArgs, itemSeparator: ", "),
                                request);
                    
                    factoryMember = Throw.IfThrows<ArgumentException, MethodInfo>(
                        () => openFactoryMethod.MakeGenericMethod(resultMethodTypeArgs),
                        request.IfUnresolved == IfUnresolved.Throw,
                        Error.NoMatchedGenericParamConstraints, factoryImplType, request);

                    if (factoryMember == null)
                        return null;
                }

                return FactoryMethod.Of(factoryMember, factoryInfo);
            }

            private readonly ReflectionFactory _openGenericFactory;
            private readonly Ref<ImTreeMap<int, KV<Type, object>>> _generatedFactories = Ref.Of(ImTreeMap<int, KV<Type, object>>.Empty);
        }

        private Type ValidateAndNormalizeImplementationType(Type implementationType)
        {
            var factoryMethodResultType = Made.FactoryMethodKnownResultType;
            if (implementationType == null || implementationType.IsAbstract())
            {
                if (Made.FactoryMethod == null)
                {
                    Throw.If(implementationType == null,
                        Error.RegisteringNullImplementationTypeAndNoFactoryMethod);
                    Throw.If(implementationType.IsAbstract(),
                        Error.RegisteringAbstractImplementationTypeAndNoFactoryMethod, implementationType);
                }

                implementationType = null; // Ensure that we do not have abstract implementation type

                // Using non-abstract factory method result type is safe for conditions and diagnostics
                if (factoryMethodResultType != null && !factoryMethodResultType.IsAbstract())
                    implementationType = factoryMethodResultType;
            }
            else if (factoryMethodResultType != null && factoryMethodResultType != implementationType)
            {
                implementationType.ThrowIfNotImplementedBy(factoryMethodResultType,
                    Error.RegisteredFactoryMethodResultTypesIsNotAssignableToImplementationType);
            }

            return implementationType;
        }

        private Expression CreateServiceExpression(MemberInfo ctorOrMethodOrMember, Expression factoryExpr, Expression[] paramExprs, Request request)
        {
            var ctor = ctorOrMethodOrMember as ConstructorInfo;
            if (ctor != null)
                return InitPropertiesAndFields(Expression.New(ctor, paramExprs), request);

            var method = ctorOrMethodOrMember as MethodInfo;
            var serviceExpr = method != null
                ? (Expression)Expression.Call(factoryExpr, method, paramExprs)
                : (ctorOrMethodOrMember is PropertyInfo
                    ? Expression.Property(factoryExpr, (PropertyInfo)ctorOrMethodOrMember)
                    : Expression.Field(factoryExpr, (FieldInfo)ctorOrMethodOrMember));

            var returnType = ctorOrMethodOrMember.GetReturnTypeOrDefault().ThrowIfNull();
            if (!returnType.IsAssignableTo(request.ServiceType))
                return Throw.IfThrows<InvalidOperationException, Expression>(
                    () => Expression.Convert(serviceExpr, request.ServiceType),
                    request.IfUnresolved == IfUnresolved.Throw,
                    Error.ServiceIsNotAssignableFromFactoryMethod, request.ServiceType, ctorOrMethodOrMember, request);

            return serviceExpr;
        }

        private static Expression TryInjectResolver(IServiceInfo serviceInfo)
        {
            return serviceInfo.ServiceType == typeof(IResolver) &&
                   serviceInfo.Details.ServiceKey == null && serviceInfo.Details.RequiredServiceType == null
                ? Container.ResolverExpr
                : null;
        }

        private static Expression TryInjectResolutionScope(IServiceInfo serviceInfo, Request request)
        {
            return serviceInfo.ServiceType == typeof(IDisposable) &&
                   serviceInfo.Details.ServiceKey == null && serviceInfo.Details.RequiredServiceType == null
                ? Container.GetResolutionScopeExpression(request)
                : null;
        }

        private FactoryMethod GetFactoryMethod(Request request)
        {
            var implType = _implementationType;
            var factoryMethodSelector = Made.FactoryMethod ?? request.Container.Rules.FactoryMethod;
            if (factoryMethodSelector != null)
            {
                var factoryMethod = factoryMethodSelector(request);
                if (factoryMethod != null && !(factoryMethod.ConstructorOrMethodOrMember is ConstructorInfo))
                {
                    var member = factoryMethod.ConstructorOrMethodOrMember;
                    var isStaticMember = member.IsStatic();

                    Throw.If(isStaticMember && factoryMethod.FactoryServiceInfo != null,
                        Error.FactoryObjProvidedButMethodIsStatic, factoryMethod.FactoryServiceInfo, factoryMethod, request);

                    Throw.If(!isStaticMember && factoryMethod.FactoryServiceInfo == null,
                        Error.FactoryObjIsNullInFactoryMethod, factoryMethod, request);
                }

                return factoryMethod.ThrowIfNull(Error.UnableToGetConstructorFromSelector, implType);
            }

            var ctors = implType.GetAllConstructors().ToArrayOrSelf();
            Throw.If(ctors.Length == 0, Error.NoPublicConstructorDefined, implType);
            Throw.If(ctors.Length > 1, Error.UnableToSelectConstructor, ctors.Length, implType);
            return FactoryMethod.Of(ctors[0]);
        }

        private Expression InitPropertiesAndFields(NewExpression newServiceExpr, Request request)
        {
            var members = request.Container.Rules.PropertiesAndFields.And(Made.PropertiesAndFields)(request);
            if (members == null)
                return newServiceExpr;

            var bindings = new List<MemberBinding>();
            foreach (var member in members)
                if (member != null)
                {
                    var memberExpr = TryInjectResolver(member) ?? TryInjectResolutionScope(member, request);
                    if (memberExpr == null)
                    {
                        var memberRequest = request.Push(member);
                        var customValue = member.Details.CustomValue;
                        if (customValue != null)
                        {
                            customValue.ThrowIfNotOf(memberRequest.ServiceType, Error.InjectedCustomValueIsOfDifferentType, memberRequest);
                            memberExpr = memberRequest.Container.GetOrAddStateItemExpression(customValue, throwIfStateRequired: true);
                        }
                        else
                        {
                            var memberFactory = memberRequest.Container.ResolveFactory(memberRequest);
                            memberExpr = memberFactory == null ? null : memberFactory.GetExpressionOrDefault(memberRequest);
                            if (memberExpr == null && request.IfUnresolved == IfUnresolved.ReturnDefault)
                                return null;
                        }
                    }

                    if (memberExpr != null)
                        bindings.Add(Expression.Bind(member.Member, memberExpr));
                }

            return bindings.Count == 0 ? (Expression)newServiceExpr : Expression.MemberInit(newServiceExpr, bindings);
        }

        private static Type[] GetClosedTypeArgsOrNullForOpenGenericType(Type openImplType, Type closedServiceType, Request request)
        {
            var serviceTypeArgs = closedServiceType.GetGenericParamsAndArgs();
            var serviceTypeGenericDef = closedServiceType.GetGenericTypeDefinition();

            var implTypeParams = openImplType.GetGenericParamsAndArgs();
            var implTypeArgs = new Type[implTypeParams.Length];

            var implementedTypes = openImplType.GetImplementedTypes();

            var matchFound = false;
            for (var i = 0; !matchFound && i < implementedTypes.Length; ++i)
            {
                var implementedType = implementedTypes[i];
                if (implementedType.IsOpenGeneric() &&
                    implementedType.GetGenericDefinitionOrNull() == serviceTypeGenericDef)
                {
                    matchFound = MatchServiceWithImplementedTypeParams(
                        implTypeArgs, implTypeParams, implementedType.GetGenericParamsAndArgs(), serviceTypeArgs);
                }
            }

            if (!matchFound)
                return request.IfUnresolved == IfUnresolved.ReturnDefault ? null
                    : Throw.For<Type[]>(Error.NoMatchedImplementedTypesWithServiceType,
                        openImplType, implementedTypes, request);

            // check constraints
            for (var i = 0; i < implTypeParams.Length; i++)
            {
                var implTypeArg = implTypeArgs[i];
                if (implTypeArg == null) continue; // skip yet unknown type arg

                var implTypeParam = implTypeParams[i];
                var implTypeParamConstraints = implTypeParam.GetGenericParamConstraints();
                if (implTypeParamConstraints.IsNullOrEmpty()) continue; // skip case with no constraints

                var constraintMatchFound = false;
                for (var j = 0; !constraintMatchFound && j < implTypeParamConstraints.Length; ++j)
                {
                    var implTypeParamConstraint = implTypeParamConstraints[j];
                    if (implTypeParamConstraint != implTypeArg &&
                        implTypeParamConstraint.IsOpenGeneric() && implTypeArg.IsGeneric())
                    {
                        constraintMatchFound = MatchServiceWithImplementedTypeParams(
                            implTypeArgs, implTypeParams,
                            implTypeParamConstraint.GetGenericParamsAndArgs(),
                            implTypeArg.GetGenericParamsAndArgs());
                    }
                }
            }

            var notMatchedIndex = Array.IndexOf(implTypeArgs, null);
            if (notMatchedIndex != -1)
                return request.IfUnresolved == IfUnresolved.ReturnDefault ? null
                    : Throw.For<Type[]>(Error.NotFoundOpenGenericImplTypeArgInService,
                        openImplType, implTypeParams[notMatchedIndex], request);

            return implTypeArgs;
        }

        private static bool MatchServiceWithImplementedTypeParams(
            Type[] resultImplArgs, Type[] implParams, Type[] serviceParams, Type[] serviceArgs, int resultCount = 0)

        {
            for (var i = 0; i < serviceParams.Length; i++)
            {
                var serviceArg = serviceArgs[i];
                var implementedParam = serviceParams[i];
                if (implementedParam.IsGenericParameter)
                {
                    var paramIndex = implParams.IndexOf(implementedParam);
                    if (paramIndex != -1)
                    {
                        if (resultImplArgs[paramIndex] == null)
                        {
                            resultImplArgs[paramIndex] = serviceArg;
                            if (++resultCount == resultImplArgs.Length)
                                return true;
                        }
                        else if (resultImplArgs[paramIndex] != serviceArg)
                            return false; // more than one service type arg is matching with single impl type param
                    }
                }
                else if (implementedParam != serviceArg)
                {
                    if (!implementedParam.IsOpenGeneric() ||
                        implementedParam.GetGenericDefinitionOrNull() != serviceArg.GetGenericDefinitionOrNull())
                        return false; // type param and arg are of different types

                    if (!MatchServiceWithImplementedTypeParams(resultImplArgs, implParams,
                        implementedParam.GetGenericParamsAndArgs(), serviceArg.GetGenericParamsAndArgs()))
                        return false; // nested match failed due either one of above reasons.
                }
            }

            return true;
        }

        #endregion
    }
}